#include <iostream>
#include <functional>
#include <string>
#include <fstream>
#include <algorithm>
using namespace std;

/**
 * for each two strings s1 s2, P(h1(s1)==h1(s2)) > P(h1(s1)==h1(s2)&&h2(s1)==h2(s2)), P is probability
 * After one round of hash, ie BKDRHash, maybe size of some file is greater than required 10M
 * for these files, we use another hash function to rehash, and mod(size/10M +1)
 * We list four effective string hash function: BKDRHash, APHash, DJBHash, JSHash
 * After four rounds of hash, test files are all < 10M
*/

int BKDRHash(std::string s) {
    unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
    unsigned int hash = 0;
    for (int i = 0; i < s.size(); ++i) {
        hash = hash * seed + s[i];
    }
    return (hash & 0x7FFFFFFF);
}

int APHash(string s) {
    unsigned int hash = 0; 
    for (int i = 0; i < s.size(); ++i) {
        if ((i & 1) == 0)
            hash ^= ((hash << 7) ^ (s[i]) ^ (hash >> 3));
        else
            hash ^= (~((hash << 11) ^ (s[i]) ^ (hash >> 5)));
    }
    return (hash & 0x7FFFFFFF);
}

int DJBHash(string s) {
    unsigned int hash = 5381;
    for (int i = 0; i < s.size(); ++i) {
        hash += (hash << 5) + s[i];
    }
    return (hash & 0x7FFFFFFF);
}

int JSHash(string s) {
    unsigned int hash = 1315423911;
    for (int i = 0; i < s.size(); ++i) {
        hash ^= ((hash << 5) + s[i] + (hash >> 2));
    }
    return (hash & 0x7FFFFFFF);
}


/**
 * Generate multiple hash files whose size < 10M
 * @param infname the original url file, size = 1G
 * @param outpath the path where temporary hash files locate
 * @param H the number of total hash files
 * @return -1 if any file errors occur, otherwise, 0.
*/
int MultiHashSplit(string infname, string outpath, int& H) {
    int (*hashf[4])(string) = {BKDRHash, APHash, DJBHash, JSHash}; 
    ifstream fin(infname);
    if (!fin) {
        return -1;
    }
    //Most effective hash function BKDRHash generates first 100 files
    ofstream fout[H];
    for (int i = 0; i < H; ++i)
        fout[i].open(outpath + "temp_" + to_string(i) + ".txt"); 
    string cur_url;
    while (getline(fin, cur_url)) {
        int h1 = BKDRHash(cur_url) % H;
        fout[h1] << cur_url << endl;
    }
    fin.close();
    for (int i = 0; i < H; ++i)
        fout[i].close();
    //Search all files generated by last hash function
    int h_index = 1, fs = 0, fe = H;
    while (h_index < 4) {
        //cout << "enter " << h_index+1 << " hash" << endl;
        for (int i = fs; i < fe; ++i) {
            string file_name = outpath + "temp_" + to_string(i) + ".txt";
            ifstream fin(file_name);
            fin.seekg(0, ios::end);
            streampos ps = fin.tellg();
            fin.close();
            //if file size > 10M, rehash to (size/10M+1) new files
            if (ps > 10000000) {
                int k = ps/10000000 + 1;
                ofstream* fout = new ofstream[k];
                for (int j = 0; j < k; ++j)
                    fout[j].open(outpath+ "temp_" + to_string(H++) + ".txt");
                ifstream fin(file_name);
                string cur_url;
                while (getline(fin, cur_url)) {
                    int h1 = (*hashf[h_index])(cur_url) % k;
                    fout[h1] << cur_url << endl;
                }
                fin.close();
                for (int j = 0; j < k; ++j)
                    fout[j].close();
                //delete old file whose size > 10M, for it has been rehash to new files
                remove(file_name.c_str());
            }   
        }
        fs = fe;
        fe = H;
        h_index++;
    }
    return 0;
}